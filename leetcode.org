#+TITLE: LeetCode 题解


* 两数之和
#+BEGIN_EXAMPLE
给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。

你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。

示例:

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
#+END_EXAMPLE

#+BEGIN_SRC python :results output
def twosum(nums, target):
    """
    :type nums: List[int]
    :type target: int
    :rtype: List[int]
    """
    target_dict = {}
    for index, num_a in enumerate(nums):
        num_b = target - num_a
        if num_b in target_dict:
            return [target_dict[num_b], index]
        else:
            target_dict[num_a] = index

nums = [2, 7, 11 ,15]
target = 9
print twosum(nums, target)
#+END_SRC

#+RESULTS:
: [0, 1]

* 两数相加[fn:1]
#+BEGIN_EXAMPLE
给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。

你可以假设除了数字 0 之外，这两个数字都不会以零开头。

示例：

输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
#+END_EXAMPLE

#+BEGIN_SRC python :results output
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

def addTwoNumbers(self, l1, l2):
    """
    :type l1: ListNode
    :type l2: ListNode
    :rtype: ListNode
    """
    head = ListNode(0)
    current = head
    sum_num = 0
    while l1 or l2:
        sum_num /= 10
        if l1:
            sum_num += l1.val
            l1 = l1.next
        if l2:
            sum_num += l2.val
            l2 = l2.next
        current.next = ListNode(sum_num % 10)
        current = current.next
    if sum_num / 10 == 1:
        current.next = ListNode(1)
    return head.next
#+END_SRC

* 无重复字符的最长子串[fn:2]
#+BEGIN_EXAMPLE
给定一个字符串，找出不含有重复字符的最长子串的长度。

示例：

给定 "abcabcbb" ，没有重复字符的最长子串是 "abc" ，那么长度就是 3。

给定 "bbbbb" ，最长的子串就是 "b" ，长度是 1。

给定 "pwwkew" ，最长子串是 "wke" ，长度是 3。请注意答案必须是一个子串，"pwke" 是 子序列  而不是子串。
#+END_EXAMPLE

#+BEGIN_SRC python :results output
def lengthOfLongestSubstring(s):
        """
        :type s: str
        :rtype: int
        """
        ans = 0
        left = 0
        last = {}
        for i in range(len(s)):
            if s[i] in last and last[s[i]] >= left:
                left = last[s[i]] + 1
            last[s[i]] = i
            ans = max(ans, i - left + 1)
        return ans

a = "pwwkew"
print lengthOfLongestSubstring(a)
#+END_SRC

#+RESULTS:
: 3

* 反转整数
#+BEGIN_EXAMPLE
给定一个 32 位有符号整数，将整数中的数字进行反转。

示例 1:

输入: 123
输出: 321
 示例 2:

输入: -123
输出: -321
示例 3:

输入: 120
输出: 21
注意:

假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0
#+END_EXAMPLE

#+BEGIN_EXAMPLE python
class Solution(object):
    def helper(self, x):
        result = 0
        while x != 0:
            result = result * 10 + x % 10
            x = x / 10
        return result
    def reverse(self, x):
        """
        :type x: int
        :rtype: int
        """
        result = self.helper(abs(x))
        if x > 0 and result < 2 ** 31 - 1:
            return result
        elif x < 0 and -result > -2 ** 31:
            return -result
        else:
            return 0
#+END_EXAMPLE



















[fn:1] https://github.com/keon/algorithms/blob/master/linkedlist/add_two_numbers.py
[fn:2] https://zhuanlan.zhihu.com/p/27434341
